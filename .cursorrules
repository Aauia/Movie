# Cursor Rules — iOS Movies App (UIKit, MVVM, iOS 15+)

Эти правила для Cursor IDE. Цель — быстро сгенерировать и поддерживать чистый проект **UIKit + MVVM** с программной версткой и интеграцией **Movies & TV Shows Database (RapidAPI)**. Главная вкладка — «В тренде». Доп. вкладки: «Новинки», «В кино сейчас», «Скоро выйдет». Детальный экран показывает «Похожие фильмы».

---

## 1) Общие требования

* Язык: **Swift 5+**.
* UI: **UIKit**, верстка **только кодом** (Auto Layout через anchors/NSLayoutConstraint, без Storyboard/XIB).
* Архитектура: **MVVM** (+ Coordinator как опционально, флаг `TODO` в коде).
* Минимальная iOS: **15.0**.
* Сеть: **URLSession** (без сторонних зависимостей). JSONDecoder с настроенным dateDecodingStrategy при необходимости.
* Кеш изображений: **NSCache\<NSURL, UIImage>** + простейший ImageLoader.
* Обработка ошибок: человеко-читаемые ошибки, заглушки (пустое состояние) и retry.
* Локализация: строки через `NSLocalizedString` (как минимум для заголовков/кнопок).
* Secrets: RapidAPI ключ/host из **.xcconfig**/**Info.plist** (не коммитить ключ).
* Код-стайл: SOLID, малые файлы, final классы, `private` где возможно, `weak self` в замыканиях.

---

## 2) API и эндпойнты (псевдо)

Base URL: `https://movies-tv-shows-database.p.rapidapi.com`
Headers:

* `X-RapidAPI-Key`: из Info.plist (или .xcconfig)
* `X-RapidAPI-Host`: `movies-tv-shows-database.p.rapidapi.com`

Используем:

* **Get Trending Movies** — главная вкладка (лента).
* **Get Now Playing Movies** — вкладка «Новинки»/«В кино сейчас» (актуальные релизы).
* **Get Upcoming Movies** — вкладка «Скоро выйдет» (предстоящие премьеры).
* **Get Movie by ID** — детальная карточка фильма.
* **Get Similar Movies (by ID)** — внутри детали блок «Похожие фильмы».

> Примечание: конкретные пути/параметры RapidAPI могут отличаться; все эндпойнты инкапсулировать в `APIEndpoint` и при необходимости скорректировать query.

---

## 3) Структура проекта (обязательная)

```
MoviesApp/
├── App/
│   ├── AppDelegate.swift
│   └── SceneDelegate.swift
├── Core/
│   ├── Network/
│   │   ├── APIClient.swift
│   │   ├── APIEndpoint.swift
│   │   └── HTTPError.swift
│   ├── ImageLoader/
│   │   └── ImageLoader.swift
│   └── Utils/
│       ├── AnyCancellableBag.swift (если понадобится)
│       └── UIHelpers.swift
├── Domain/
│   ├── Models/
│   │   ├── Movie.swift
│   │   └── MovieDetail.swift
│   └── Services/
│       └── MoviesService.swift
├── Features/
│   ├── Trending/ (Главная вкладка)
│   │   ├── TrendingViewController.swift
│   │   ├── TrendingViewModel.swift
│   │   ├── TrendingCell.swift
│   │   └── TrendingHeaderView.swift (гор. слайдер, опц.)
│   ├── NowPlaying/
│   │   ├── NowPlayingViewController.swift
│   │   ├── NowPlayingViewModel.swift
│   │   └── NowPlayingCell.swift
│   ├── Upcoming/
│   │   ├── UpcomingViewController.swift
│   │   ├── UpcomingViewModel.swift
│   │   └── UpcomingCell.swift
│   └── Detail/
│       ├── MovieDetailViewController.swift
│       ├── MovieDetailViewModel.swift
│       ├── SimilarMoviesView.swift (UICollectionView)
│       └── SimilarMoviesDataSource.swift
├── Resources/
│   ├── Info.plist
│   └── Assets.xcassets (placeholder/poster)
└── Config/
    └── Secrets.xcconfig (в .gitignore)
```

---

## 4) Навигация

* Корень: `UITabBarController` с 3 вкладками:

  1. **TrendingViewController** (главная). Заголовок: "В тренде".
  2. **NowPlayingViewController**. Заголовок: "В кино сейчас" или "Новинки" (реши по смыслу для твоего API).
  3. **UpcomingViewController**. Заголовок: "Скоро выйдет".
* Каждая вкладка обёрнута в `UINavigationController`.
* Переход на деталь: `push(MovieDetailViewController(movieID: ...))`.

---

## 5) MVVM договорённости

**ViewModel**

* Имеет только входы (методы пользовательских интеракций/запросы) и выходы (замыкания/обсерваблы) для обновления UI.
* Не знает UIKit. Хранит только данные модели и состояния: `isLoading`, `error`, `items`.
* Сеть вызывает через `MoviesService`.

**ViewController**

* Создаёт UI, подписывается на VM-выходы, вызывает входы VM по событиям (viewDidLoad, pull-to-refresh, выбор элемента).
* Не содержит бизнес-логики и сетевых вызовов.

---

## 6) Состояния UI (обязательно)

Для списков и деталей поддержать:

* loading (индикатор/скелетон),
* content,
* empty (нет данных),
* error (кнопка Retry).

Пример в VM:

```swift
enum ViewState<T> {
    case idle
    case loading
    case content(T)
    case empty
    case error(String)
}
```

---

## 7) API слой (контракты)

`APIEndpoint` (enum): формирует URLRequest.
`APIClient`: выполняет запросы, декодирует, мапит сетевые/HTTP ошибки в `HTTPError`.
`MoviesService`: фасад над `APIClient` с методами:

```swift
protocol MoviesServiceProtocol {
    func getTrending(page: Int) async throws -> [Movie]
    func getNowPlaying(page: Int) async throws -> [Movie]
    func getUpcoming(page: Int) async throws -> [Movie]
    func getMovie(id: String) async throws -> MovieDetail
    func getSimilar(id: String, page: Int) async throws -> [Movie]
}
```

> Использовать `async/await`. Для iOS 15 это доступно. В контроллерах — `Task { await vm.load() }`.

---

## 8) Модели (минимум)

```swift
struct Movie: Decodable, Hashable {
    let id: String
    let title: String
    let year: String?
    let rating: Double?
    let poster: URL?
}

struct MovieDetail: Decodable, Hashable {
    let id: String
    let title: String
    let overview: String?
    let year: String?
    let rating: Double?
    let genres: [String]?
    let poster: URL?
    let releaseDate: String?
}
```

> Поля/типы привести в соответствие реальным JSON полям RapidAPI (через CodingKeys).

---

## 9) Главная (Trending)

**UI:**

* `UICollectionViewCompositionalLayout`: сетка постеров (2–3 в ряд на iPhone), pull-to-refresh.
* В `navigationItem.searchController = UISearchController(...)`.

**VM:**

* `func loadTrending(reset: Bool)`
* `func search(query: String)` (если используешь отдельный поисковый эндпойнт; если нет — локальный фильтр).
* Пагинация: подгружать следующую страницу по достижению низа.
* Выходы: `state: ViewState<[Movie]>`, `onAppend(items: [Movie])` для пагинации.

---

## 10) Новинки (Now Playing) и Скоро выйдет (Upcoming)

* Такие же экраны-списки, отдельные VM: `NowPlayingViewModel`, `UpcomingViewModel`.
* Кнопка сортировки (правый `UIBarButtonItem` с `UIMenu`): по рейтингу, по году (локально).
* Даты релиза показывать в ячейке (для «Скоро выйдет»).

---

## 11) Детальный экран

**UI:** постер, заголовок, жанры, рейтинг (звёздочки/число), дата, overview (многострочный), секция «Похожие» (гор. коллекция или секция ниже).

**VM:**

```swift
final class MovieDetailViewModel {
    @Published private(set) var state: ViewState<MovieDetail> = .idle
    @Published private(set) var similar: [Movie] = []

    func load(id: String) async
    func reloadSimilar(id: String) async
}
```

---

## 12) ImageLoader (кеш)

* Singleton `ImageLoader.shared` с `NSCache`.
* Метод: `func load(_ url: URL, into imageView: UIImageView)` — ставит placeholder, отменяет старую задачу на реюз, кладёт в кеш по URL.
* Для коллекций использовать `prepareForReuse()` для сброса изображения.

---

## 13) Тесты

* Unit-тесты для парсинга `Movie`, `MovieDetail` (JSON fixtures).
* VM-тесты: мок `MoviesService`, проверка состояний `.loading → .content/.error`.

---

## 14) Конфигурация ключей

* `Config/Secrets.xcconfig` (в `.gitignore`):

```
RAPID_API_KEY = YOUR_KEY
RAPID_API_HOST = movies-tv-shows-database.p.rapidapi.com
```

* В `Info.plist` ссылки `$(RAPID_API_KEY)`, `$(RAPID_API_HOST)` и чтение их в `APIClient`.

---

## 15) Шаблоны кода (Cursor, сгенерируй)

### 15.1 APIEndpoint.swift

```swift
import Foundation

enum APIEndpoint {
    static let baseURL = URL(string: "https://movies-tv-shows-database.p.rapidapi.com")!

    case trending(page: Int)
    case nowPlaying(page: Int)
    case upcoming(page: Int)
    case movie(id: String)
    case similar(id: String, page: Int)

    var path: String { /* TODO: скорректировать под фактический API */
        switch self {
        case .trending(let page): return "/trending?type=movie&page=\(page)"
        case .nowPlaying(let page): return "/now-playing?page=\(page)"
        case .upcoming(let page): return "/upcoming?page=\(page)"
        case .movie(let id): return "/movie?id=\(id)"
        case .similar(let id, let page): return "/similar?id=\(id)&page=\(page)"
        }
    }
}
```

### 15.2 APIClient.swift

```swift
import Foundation

enum HTTPError: Error { case badURL, noData, decoding, server(Int), unknown }

final class APIClient {
    private let session: URLSession
    private let apiKey: String
    private let apiHost: String

    init(session: URLSession = .shared) {
        self.session = session
        self.apiKey = Bundle.main.object(forInfoDictionaryKey: "RAPID_API_KEY") as? String ?? ""
        self.apiHost = Bundle.main.object(forInfoDictionaryKey: "RAPID_API_HOST") as? String ?? ""
    }

    func request<T: Decodable>(_ endpoint: APIEndpoint) async throws -> T {
        let url = APIEndpoint.baseURL.appending(path: endpoint.path)
        var req = URLRequest(url: url)
        req.setValue(apiKey, forHTTPHeaderField: "X-RapidAPI-Key")
        req.setValue(apiHost, forHTTPHeaderField: "X-RapidAPI-Host")
        let (data, resp) = try await session.data(for: req)
        if let http = resp as? HTTPURLResponse, !(200...299).contains(http.statusCode) {
            throw HTTPError.server(http.statusCode)
        }
        do { return try JSONDecoder().decode(T.self, from: data) }
        catch { throw HTTPError.decoding }
    }
}
```

### 15.3 MoviesService.swift

```swift
import Foundation

protocol MoviesServiceProtocol {
    func getTrending(page: Int) async throws -> [Movie]
    func getNowPlaying(page: Int) async throws -> [Movie]
    func getUpcoming(page: Int) async throws -> [Movie]
    func getMovie(id: String) async throws -> MovieDetail
    func getSimilar(id: String, page: Int) async throws -> [Movie]
}

final class MoviesService: MoviesServiceProtocol {
    private let api: APIClient
    init(api: APIClient = APIClient()) { self.api = api }

    func getTrending(page: Int) async throws -> [Movie] { try await api.request(.trending(page: page)) }
    func getNowPlaying(page: Int) async throws -> [Movie] { try await api.request(.nowPlaying(page: page)) }
    func getUpcoming(page: Int) async throws -> [Movie] { try await api.request(.upcoming(page: page)) }
    func getMovie(id: String) async throws -> MovieDetail { try await api.request(.movie(id: id)) }
    func getSimilar(id: String, page: Int) async throws -> [Movie] { try await api.request(.similar(id: id, page: page)) }
}
```

### 15.4 ViewModels (пример для Trending)

```swift
import Foundation

final class TrendingViewModel {
    private let service: MoviesServiceProtocol
    private(set) var items: [Movie] = []
    var onStateChange: ((ViewState<[Movie]>) -> Void)?
    private var page = 1
    private var isLoading = false

    init(service: MoviesServiceProtocol = MoviesService()) { self.service = service }

    @MainActor
    func load(reset: Bool = false) async {
        guard !isLoading else { return }
        isLoading = true
        if reset { page = 1; items.removeAll() }
        onStateChange?(.loading)
        do {
            let new = try await service.getTrending(page: page)
            if reset && new.isEmpty { onStateChange?(.empty) }
            else {
                items.append(contentsOf: new)
                onStateChange?(.content(items))
                page += 1
            }
        } catch {
            onStateChange?(.error("Не удалось загрузить тренды"))
        }
        isLoading = false
    }
}
```

### 15.5 TrendingViewController (скелет)

```swift
import UIKit

final class TrendingViewController: UIViewController {
    private let vm = TrendingViewModel()
    private lazy var collection = UICollectionView(frame: .zero, collectionViewLayout: layout())
    private let refresh = UIRefreshControl()

    override func viewDidLoad() {
        super.viewDidLoad()
        title = NSLocalizedString("В тренде", comment: "")
        view.backgroundColor = .systemBackground
        navigationItem.searchController = UISearchController(searchResultsController: nil)
        setupCollection()
        bind()
        Task { await vm.load(reset: true) }
    }

    private func bind() {
        vm.onStateChange = { [weak self] state in
            guard let self else { return }
            switch state {
            case .loading: self.refresh.beginRefreshing()
            case .content: self.collection.reloadData(); self.refresh.endRefreshing()
            case .empty: self.showEmpty()
            case .error(let msg): self.showError(msg)
            case .idle: break
            }
        }
    }

    private func setupCollection() {
        collection.translatesAutoresizingMaskIntoConstraints = false
        collection.register(TrendingCell.self, forCellWithReuseIdentifier: TrendingCell.reuseID)
        collection.dataSource = self
        collection.delegate = self
        collection.refreshControl = refresh
        refresh.addTarget(self, action: #selector(onRefresh), for: .valueChanged)
        view.addSubview(collection)
        NSLayoutConstraint.activate([
            collection.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor),
            collection.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            collection.trailingAnchor.constraint(equalTo: view.trailingAnchor),
            collection.bottomAnchor.constraint(equalTo: view.bottomAnchor)
        ])
    }

    private func layout() -> UICollectionViewLayout {
        let item = NSCollectionLayoutItem(layoutSize: .init(widthDimension: .fractionalWidth(0.5), heightDimension: .estimated(250)))
        item.contentInsets = .init(top: 8, leading: 8, bottom: 8, trailing: 8)
        let group = NSCollectionLayoutGroup.horizontal(layoutSize: .init(widthDimension: .fractionalWidth(1), heightDimension: .estimated(260)), subitems: [item, item])
        let section = NSCollectionLayoutSection(group: group)
        return UICollectionViewCompositionalLayout(section: section)
    }

    @objc private func onRefresh() { Task { await vm.load(reset: true) } }
}

extension TrendingViewController: UICollectionViewDataSource, UICollectionViewDelegate {
    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int { vm.items.count }
    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: TrendingCell.reuseID, for: indexPath) as! TrendingCell
        cell.configure(vm.items[indexPath.item])
        return cell
    }
    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
        let id = vm.items[indexPath.item].id
        navigationController?.pushViewController(MovieDetailViewController(movieID: id), animated: true)
    }
}
```

### 15.6 MovieDetailViewModel / ViewController — аналогично, плюс загрузка similar.

---

## 16) UI/UX детали

* Ячейки: скругление 12pt, тень лёгкая, `contentView.clipsToBounds = true` + `layer.cornerRadius`.
* Poster `contentMode = .scaleAspectFill`, placeholder (серый прямоугольник).
* Пагинация: при прокрутке до \~80% высоты — `await vm.load(reset: false)`.
* Error/Empty: простые `UILabel` + `UIButton("Повторить")`.

---

## 17) Git и сдача

* Инициализируй git, коммитьте атомарно: `chore(project)`, `feat(trending)`, `feat(detail)`, `feat(similar)`, `feat(now-playing)`, `feat(upcoming)`, `fix(...)`.
* Убедись, что `Config/Secrets.xcconfig` в `.gitignore`.
* Сборка без ошибок/ворнингов.
* Видео-демо: iOS Simulator `⌘ + R` для записи.

---

## 18) Acceptance Criteria (чеклист)

* [ ] Проект компилируется на iOS 15+.
* [ ] UIKit-only, без Storyboard.
* [ ] MVVM: VC без сетевой логики.
* [ ] Главная вкладка «В тренде» с пагинацией и pull-to-refresh.
* [ ] Вкладки «В кино сейчас/Новинки» и «Скоро выйдет».
* [ ] Детальная страница фильма + «Похожие».
* [ ] Кеш изображений.
* [ ] Ошибки/пустое состояние/Retry.
* [ ] Ключи из .xcconfig/Info.plist (без утечки ключа в репо).
* [ ] Минимальные unit-тесты моделей/VM.

---

## 19) Инструкции для Cursor (единый промпт)

**Cursor, действуй по шагам:**

1. Создай структуру папок из раздела 3.
2. Сгенерируй файлы из раздела 15 (скелеты) + заглушки оставшихся VC/VM.
3. Имплементируй `APIEndpoint` по реальным путям RapidAPI (проверь документацию), не меняя интерфейс `MoviesServiceProtocol`.
4. Реализуй `ImageLoader` с NSCache и отменой задач при реюзе.
5. Сделай три вкладки в `SceneDelegate`: Trending, NowPlaying, Upcoming.
6. В каждом VC — UICollectionView (CompositionalLayout), ячейки с постером и заголовком.
7. В Trending добавь UISearchController (пока локальный фильтр по `title`, если нет стабильного search endpoint).
8. В Detail — основной блок + горизонтальная коллекция «Похожие».
9. Добавь состояния UI (loading/empty/error) и Retry.
10. Добавь простые unit-тесты на парсинг JSON и VM-состояния.

**Важно:** поддерживай чистый MVVM, избегай бизнес-логики в VC, используй `async/await`, закрывай утечки (weak self), ограничивай область видимости (`private`).
